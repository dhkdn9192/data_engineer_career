# Hash table


## Hashing

해시함수란 데이터의 효율적 관리를 목적으로 <b>임의의 길이의 데이터를 고정된 길이의 데이터로 매핑</b>하는 함수입니다. 
이 때 매핑 전 원래 데이터의 값을 <b>키(key)</b>, 매핑 후 데이터의 값을 <b>해시값(hash value)</b>, 매핑하는 과정 자체를 <b>해싱(hashing)</b>라고 합니다.

해시함수는 해쉬값의 개수보다 대개 많은 키값을 해쉬값으로 변환(many-to-one 대응)하기 때문에 
해시함수가 서로 다른 두 개의 키에 대해 동일한 해시값을 내는 <b>해시충돌(collision)</b>이 발생하게 됩니다. 

<br>

## Hashing의 장점

해시충돌이 발생할 가능성이 있음에도 해시테이블을 쓰는 이유는 <b>적은 리소스로 많은 데이터를 효율적으로 관리</b>하기 위해서입니다. 
- 계산복잡도
  - 이진탐색트리: O(log n)
  - 해싱: O(1)
  
<br>

## Hash table

해시함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값을 색인(index) 혹은 주소 삼아 
데이터의 값(value)을 키와 함께 저장하는 자료구조를 <b>해시테이블(hash table)</b>이라고 합니다. 
이 때 데이터가 저장되는 곳을 <b>버킷(bucket) 또는 슬롯(slot)</b>이라고 합니다. 
해시테이블의 기본 연산은 <b>삽입, 삭제, 탐색</b>(search)입니다.

보통의 경우 “해시테이블 크기(m)가 실제 사용하는 키 개수(n)보다 적은 해시테이블”을 운용합니다.

<br>

## Collision

해시충돌 문제를 해결하기 위해 다양한 기법들이 고안됐습니다. 
<b>chining</b>은 해시테이블의 크기를 유연하게 만들고, 
</b>open addressing</b>은 해시테이블 크기는 고정시키되 저장해 둘 위치를 잘 찾는 데 관심을 둔 구조입니다. 
이뿐 아니라 <b>해시함수를 개선</b>하는 접근도 있습니다. 

<br>

### chaining
한 버킷당 들어갈 수 있는 엔트리의 수에 제한을 두지 않음으로써 모든 자료를 해시테이블에 담습니다. 
해당 버킷에 데이터가 이미 있다면 <b>체인처럼 노드를 추가하여 다음 노드를 가리키는 방식으로 구현(연결리스트)</b>합니다. 
유연하다는 장점을 가지나 <b>메모리 문제</b>를 야기할 수 있습니다.

<br>

### open addressing
chaining과 달리 한 버킷당 들어갈 수 있는 엔트리가 하나뿐인 해시테이블입니다. 
<b>해시함수로 얻은 주소가 아닌, 다른 주소에 데이터를 저장할 수 있도록 허용</b>합니다. 
메모리 문제가 발생하지 않으나 <b>해시충돌</b>이 생길 수 있습니다.

특정 해시값에 키가 몰리게 되면 open addressing의 효율성이 크게 떨어집니다. 
해시충돌은 <b>탐사(probing)</b> 방식으로 해결할 수 있습니다. 
탐사란 삽입, 삭제, 탐색을 수행하기 위해 해시테이블 내 새로운 주소(해시값)를 찾는 과정입니다.


### universal hasing
다수의 해시함수를 만들고, 이 해시함수의 집합 H에서 <b>무작위로 해시함수를 선택</b>해 해시값을 만드는 기법입니다. 
H에서 무작위로 뽑은 해시함수가 주어졌을 때 임의의 키값을 임의의 해시값에 매핑할 확률을 1/m로 만드려는 것이 목적입니다. 


<br>

## Reference
- https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/
- https://en.wikipedia.org/wiki/Hash_table
